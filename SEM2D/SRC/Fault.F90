!>
!!\file Fault.F90
!!\brief
!!\author
!!\version 1.0
!!\date 10/03/2009
!!
!<

module sfaults

    ! Modified by Gaetano 18/03/05
    ! #####################################################################################
    !  Two different problem are analyzed for the moment:
    !  The problem is set in the integer variable "Problem_type"
    !  Problem_type = 1     => Nucleation generated by raising the traction in a patch
    !                          Uniform sigma0, Dc and mus for a linear slip weakening
    !  Problem_type = 2     => Andrews crack propagating at a given constant velocity v
    !                          The slope and DeltaTau are constant on the fault
    ! #####################################################################################

    type Face_Fault

       logical :: Coherency
       logical, dimension (:), pointer :: log_face
       integer :: Face_UP, Face_DOWN, ngll, mat_index, mat_dir
       integer, dimension (0:1) :: Face_to_Vertex
       real, dimension (0:1) :: X_Vertex, Z_Vertex
       real, dimension (:), pointer :: ds, tau0, sigma0, mus, mud, Dc, Bt, Cgamma
       real, dimension (:), pointer :: Ct, b, w , beta_p, AbsDeltau0, distance
       real, dimension (:,:), pointer :: DeltaV, Traction, Deltau,normal

    end type Face_Fault

    type Vertex_Fault

       logical :: Termination, log_vertex
       integer :: Vertex_UP, Vertex_DOWN, mat_index
       real :: tau0, sigma0, mus, mud, Dc, Bt, CGamma, MassMat_UP, MassMat_Down
       real :: Ct, b, w, beta_p, Absdeltau0, distance
       real, dimension (0:1) :: DeltaV, Traction, Deltau,normal

    end type Vertex_Fault

    type Fault

       logical :: smoothing
       integer :: n_face, n_vertex,  Problem_type
       real :: imposed_Tolerance, dx_smoothing
       type(Face_Fault), dimension (:), pointer :: fFace
       type(Vertex_Fault), dimension (:), pointer :: fVertex

    end type Fault

contains

    !  ########################################################################################
    !>
    !! \brief
    !!
    !! \param type (Face_Fault), intent (INOUT) Face
    !! \param real, dimension (1:Face%ngll-2,0:1), intent (IN) Vfree
    !! \param real, intent (IN) dt
    !! \param real, intent (IN) tolerance_imposed
    !<


    subroutine traction_on_face_sw (Face, Vfree, dt, tolerance_imposed)
        implicit none

        type (Face_Fault), intent (INOUT) :: Face
        real, dimension (1:Face%ngll-2,0:1), intent (IN) :: Vfree
        real, intent (IN) :: dt, tolerance_imposed

        integer :: i, ngll
        real :: tolerance, Tract_aus, Tracn_aus, delta_disp, Treshold_SW_UP, Treshold_SW_DOWN
        real, dimension (1:Face%ngll-2,0:1) :: Vfree_aus, Vfree_aus2

        Vfree_aus2 = dt *Vfree
        ngll = Face%ngll
        ! Rotation of Vfree
        Vfree_aus(1:ngll-2,0) = - Face%normal(1:ngll-2,1) * Vfree_aus2(1:ngll-2,0) + Face%normal(1:ngll-2,0) * Vfree_aus2(1:ngll-2,1)
        Vfree_aus(1:ngll-2,1) = Face%normal(1:ngll-2,0) * Vfree_aus2(1:ngll-2,0) + Face%normal(1:ngll-2,1) * Vfree_aus2(1:ngll-2,1)

        Vfree_aus2(1:ngll-2,0) = Face%Deltav(1:ngll-2,0) + Vfree_aus(1:ngll-2,0)
        Vfree_aus2(1:ngll-2,1) = Face%Deltau(1:ngll-2,1) + dt * Face%Deltav(1:ngll-2,1) + 0.5 * dt * Vfree_aus(1:ngll-2,1)

        Vfree_aus (1:ngll-2,0) = - 1./Face%Cgamma(1:ngll-2) * Vfree_aus2(1:ngll-2,0)
        Vfree_aus (1:ngll-2,1) = - 2./(Face%Cgamma(1:ngll-2)*dt) * Vfree_aus2(1:ngll-2,1)

        do i = 1, ngll-2
            Tolerance = abs( Vfree_aus(i,1) / Face%sigma0(i) )
            if (Tolerance <  tolerance_imposed) then
                Tracn_aus = Face%sigma0(i)
            else
                Tracn_aus = Vfree_aus (i,1) + Face%sigma0(i)
            endif
            if (Tracn_aus < 0) then
                Face%Traction(i,1) = Vfree_aus(i,1)
                Face%Deltav(i,1) = 0.
                Tract_aus = Vfree_aus(i,0) + Face%tau0(i)
                delta_disp = abs (Face%Deltau(i,0))
                if (Face%AbsDeltau0(i) > delta_disp ) then
                    delta_disp = Face%AbsDeltau0(i)
                else
                    Face%AbsDeltau0(i) = delta_disp
                endif
                if (delta_disp < Face%Dc(i)) then
                    Treshold_SW_UP = Face%mus(i) - (Face%mus(i) - Face%mud(i))/Face%Dc(i) * delta_disp
                else
                    Treshold_SW_UP = Face%mud(i)
                endif
                Treshold_SW_UP = - Treshold_SW_UP * Tracn_aus
                Treshold_SW_DOWN= - Treshold_SW_UP
                if (Tract_aus <= Treshold_SW_UP .and. Tract_aus >= Treshold_SW_DOWN) then
                    !Face%Traction(i,0) = Tract_aus - Face%tau0(i)
                    Face%Traction(i,0) = Vfree_aus(i,0)
                    Face%Deltav (i,0) = 0.
                else if (Tract_aus >Treshold_SW_UP) then
                    Face%Traction(i,0) = Treshold_SW_UP - Face%tau0(i)
                    Face%Deltav (i,0) =  - (Tract_aus-Treshold_SW_UP) * Face%Cgamma(i)
                else
                    Face%Traction(i,0) = Treshold_SW_DOWN - Face%tau0(i)
                    Face%Deltav (i,0) =  - (Tract_aus-Treshold_SW_DOWN) * Face%Cgamma(i)
                endif
                Face%Deltau(i,0:1) = Face%Deltau(i,0:1)  + dt * Face%Deltav(i,0:1)

            else     ! opening
                Face%Deltav(i,1) = - Face%Deltau(i,1)
                Face%Deltau(i,1) = Vfree_aus2(i,1)
                Face%Deltav(i,1) = (Face%Deltau(i,1) + Face%Deltav(i,1))/dt
                Face%Deltav(i,0) =   Vfree_aus2(i,0) - Face%Cgamma(i) * Face%tau0(i)
                Face%Deltau(i,0) = Face%Deltau(i,0) + dt * Face%Deltav(i,0)
                Face%Traction(i,0) = - Face%tau0(i)
                Face%Traction(i,1) = - Face%sigma0(i)

            endif
        enddo

        return
    end subroutine traction_on_face_sw
    !  ########################################################################################
    !>
    !! \brief
    !!
    !! \param type (Face_Fault), intent (INOUT) Face
    !<


    subroutine rotate_traction_face(Face)
        implicit none

        type (Face_Fault), intent (INOUT) :: Face

        integer :: ngll
        real, dimension (1:Face%ngll-2,0:1) :: Vfree_aus

        ! Rotate traction
        ngll = Face%ngll
        Vfree_aus(1:ngll-2,0) = - Face%normal(1:ngll-2,1) * Face%Traction(1:ngll-2,0) + Face%normal(1:ngll-2,0) * Face%Traction(1:ngll-2,1)
        Vfree_aus(1:ngll-2,1) = Face%normal(1:ngll-2,0) * Face%Traction(1:ngll-2,0) + Face%normal(1:ngll-2,1) * Face%Traction(1:ngll-2,1)
        Face%Traction(1:ngll-2,0:1) = Vfree_aus(1:ngll-2,0:1)
        return
    end subroutine rotate_traction_face
    !  ########################################################################################

    !>
    !! \brief
    !!
    !! \param type (Vertex_Fault), intent (INOUT) Vertex
    !! \param real, dimension (0:1), intent (IN) Vfree
    !! \param real, intent (IN) dt
    !! \param real, intent (IN) tolerance_imposed
    !<


    subroutine traction_on_vertex_sw (Vertex, Vfree, dt, tolerance_imposed)
        implicit none

        type (Vertex_Fault), intent (INOUT) :: Vertex
        real, dimension (0:1), intent (IN) :: Vfree
        real, intent (IN) :: dt, tolerance_imposed

        real :: tolerance, Tract_aus, Tracn_aus, delta_disp, Treshold_SW_UP, Treshold_SW_DOWN
        real, dimension (0:1) :: Vfree_aus, Vfree_aus2

        Vfree_aus2(0:1) = dt *Vfree(0:1)

        ! Rotation of V_free
        Vfree_aus(0) = - Vertex%normal(1) * Vfree_aus2(0) + Vertex%normal(0) * Vfree_aus2(1)
        Vfree_aus(1) = Vertex%normal(0) * Vfree_aus2(0) + Vertex%normal(1) * Vfree_aus2(1)

        Vfree_aus2(0) = Vertex%Deltav(0) + Vfree_aus(0)
        Vfree_aus2(1) = Vertex%Deltau(1) + dt * Vertex%Deltav(1) + 0.5 * dt * Vfree_aus(1)

        Vfree_aus (0) = - 1./Vertex%Cgamma * Vfree_aus2(0)
        Vfree_aus (1) = - 2./(Vertex%Cgamma*dt) * Vfree_aus2(1)

        Tolerance = abs(Vfree_aus(1) / Vertex%sigma0)
        if (Tolerance <  tolerance_imposed) then
            Tracn_aus = Vertex%sigma0
        else
            Tracn_aus = Vfree_aus (1) + Vertex%sigma0
        endif
        if (Tracn_aus < 0) then

            Vertex%Traction(1) = Vfree_aus(1)
            Vertex%Deltav(1) = 0.
            Tract_aus = Vfree_aus(0) + Vertex%tau0
            delta_disp = abs (Vertex%Deltau(0))
            if (Vertex%AbsDeltau0 > delta_disp ) then
                delta_disp = Vertex%AbsDeltau0
            else
                Vertex%AbsDeltau0 = delta_disp
            endif
            if (delta_disp < Vertex%Dc) then
                Treshold_SW_UP = Vertex%mus - (Vertex%mus - Vertex%mud)/Vertex%Dc * delta_disp
            else
                Treshold_SW_UP = Vertex%mud
            endif
            Treshold_SW_UP = - Treshold_SW_UP * Tracn_aus
            Treshold_SW_DOWN = - Treshold_SW_UP
            if (Tract_aus <= Treshold_SW_UP .and. Tract_aus>= Treshold_SW_DOWN) then
                !Vertex%Traction(0) = Tract_aus - Vertex%tau0
                Vertex%Traction(0) =Vfree_aus(0)
                Vertex%Deltav (0) = 0.
            else if (Tract_aus > Treshold_SW_UP) then
                Vertex%Traction(0) = Treshold_SW_UP - Vertex%tau0
                Vertex%Deltav (0) =  - (Tract_aus-Treshold_SW_UP) * Vertex%Cgamma
            else
                Vertex%Traction(0) = Treshold_SW_DOWN - Vertex%tau0
                Vertex%Deltav (0) =  - (Tract_aus-Treshold_SW_DOWN) * Vertex%Cgamma
            endif
            Vertex%Deltau(0:1) = Vertex%Deltau(0:1)  + dt * Vertex%Deltav(0:1)
        else     ! opening
            Vertex%Deltav(1) = -  Vertex%Deltau(1)
            Vertex%Deltau(1) = Vfree_aus2(1)
            Vertex%Deltav(1) =  (Vertex%Deltau(1)+Vertex%Deltav(1))/dt
            Vertex%Deltav(0) = Vfree_aus2(0) - Vertex%Cgamma * Vertex%tau0
            Vertex%Deltau(0) = Vertex%Deltau(0)  + dt * Vertex%Deltav(0)
            Vertex%Traction(0) = - Vertex%tau0
            Vertex%Traction(1) = - Vertex%sigma0

        endif

        return
    end subroutine traction_on_vertex_sw
    !  ########################################################################################
    !>
    !! \brief
    !!
    !! \param type (Vertex_Fault), intent (INOUT) Vertex
    !<


    subroutine rotate_traction_vertex (Vertex)
        implicit none

        type (Vertex_Fault), intent (INOUT) :: Vertex

        real, dimension (0:1) :: Vfree_aus


        ! Rotate traction
        Vfree_aus(0) = - Vertex%normal(1) * Vertex%Traction(0) + Vertex%normal(0) * Vertex%Traction(1)
        Vfree_aus(1) = Vertex%normal(0) * Vertex%Traction(0) + Vertex%normal(1) * Vertex%Traction(1)

        Vertex%Traction(0:1) = Vfree_aus(0:1)

        return
    end subroutine rotate_traction_vertex
    !  ########################################################################################
    !>
    !! \brief
    !!
    !! \param type (Face_Fault), intent (INOUT) Face
    !! \param real, dimension (1:Face%ngll-2,0:1), intent (IN) Vfree
    !! \param real, intent (IN) dt
    !! \param real, intent (IN) tolerance_imposed
    !<


    subroutine traction_on_face_adhesion (Face, Vfree, dt, tolerance_imposed)
        implicit none

        type (Face_Fault), intent (INOUT) :: Face
        real, dimension (1:Face%ngll-2,0:1), intent (IN) :: Vfree
        real, intent (IN) :: dt, tolerance_imposed

        integer :: i, ngll
        real :: tolerance, Tract_aus, Tracn_aus, delta_disp, Treshold_AD
        real, dimension (1:Face%ngll-2,0:1) :: Vfree_aus, Vfree_aus2

        Vfree_aus = Face%Deltav + dt *Vfree
        ngll = Face%ngll
        do i =0,1
            Vfree_aus2(1:ngll-2,i) = - 1/Face%Cgamma(1:ngll-2) * Vfree_aus(1:ngll-2,i)
        enddo

        ! Rotation of Vfree
        Vfree_aus(1:ngll-2,0) = Face%normal(1:ngll-2,1) * Vfree_aus2(1:ngll-2,0) - Face%normal(1:ngll-2,0) * Vfree_aus2(1:ngll-2,1)
        Vfree_aus(1:ngll-2,1) = Face%normal(1:ngll-2,0) * Vfree_aus2(1:ngll-2,0) + Face%normal(1:ngll-2,1) * Vfree_aus2(1:ngll-2,1)

        do i = 1, ngll-2
            Tolerance = abs(Vfree_aus(i,1)) / Face%sigma0(i)
            if (Tolerance <  tolerance_imposed) then
                Tracn_aus = - Face%sigma0(i)
            else
                Tracn_aus = Vfree_aus (i,1) - Face%sigma0(i)
            endif
            if (Tracn_aus < 0) then
                Face%Traction(i,1) = Tracn_aus + Face%sigma0(i)
                Face%Deltav(i,1) = 0.
                Tract_aus = Vfree_aus(i,0) + Face%tau0(i)
                delta_disp = abs (Face%Deltau(i,0))

                if (Face%Ct(i) * delta_disp**2 * Face%beta_p(i) < Face%w(i) .and. Face%log_face(i) ) then
                    Face%beta_p(i) = 1
                else
                    Face%log_face (i) = .false.
                    Face%beta_p(i) = Face%beta_p(i) - dt /Face%b(i) * (Face%Ct(i) * delta_disp**2 * Face%beta_p(i) - Face%w(i))
                endif
                if (Face%beta_p(i) < 0) face%beta_p(i) = 0

                !Tracn_aus = - Face%sigma0(i)

                Treshold_AD = -Tracn_aus * Face%mud(i) + Face%Ct(i) * delta_disp * Face%beta_p(i)**2
                !if (n==11) print *, i, Treshold_AD , Tract_aus

                if (Tract_aus <= Treshold_AD) then
                    Face%Traction(i,0) = Tract_aus - Face%tau0(i)
                    Face%Deltav (i,0) = 0.
                else
                    Face%Traction(i,0) = Treshold_AD - Face%tau0(i)
                    Face%Deltav (i,0) =  - (Tract_aus-Treshold_AD) * Face%Cgamma(i)
                endif
            else     ! opening
                Face%Deltav(i,1) = - Tracn_aus * Face%CGamma(i)
                Face%Deltav(i,0) = 0.
                Face%Traction(i,0:1) = 0.
            endif
            Face%Deltau(i,0:1) = Face%Deltau(i,0:1)  + dt * Face%Deltav(i,0:1)
        enddo
        ! Rotate traction
        Vfree_aus(1:ngll-2,0) = Face%normal(1:ngll-2,1) * Face%Traction(1:ngll-2,0) + Face%normal(1:ngll-2,0) * Face%Traction(1:ngll-2,1)
        Vfree_aus(1:ngll-2,1) = -Face%normal(1:ngll-2,0) * Face%Traction(1:ngll-2,0) + Face%normal(1:ngll-2,1) * Face%Traction(1:ngll-2,1)
        Face%Traction(1:ngll-2,0:1) = Vfree_aus(1:ngll-2,0:1)

        return
    end subroutine traction_on_face_adhesion

    !  ########################################################################################
    !>
    !! \brief
    !!
    !! \param type (Vertex_Fault), intent (INOUT) Vertex
    !! \param real, dimension (0:1), intent (IN) Vfree
    !! \param real, intent (IN) dt
    !! \param real, intent (IN) tolerance_imposed
    !<


    subroutine traction_on_vertex_adhesion (Vertex, Vfree, dt, tolerance_imposed)
        implicit none

        type (Vertex_Fault), intent (INOUT) ::Vertex
        real, dimension (0:1), intent (IN) :: Vfree
        real, intent (IN) :: dt, tolerance_imposed

        integer :: i
        real :: tolerance, Tract_aus, Tracn_aus, delta_disp, Treshold_AD
        real, dimension (0:1) :: Vfree_aus, Vfree_aus2

        Vfree_aus = Vertex%Deltav + dt *Vfree

        do i =0,1
            Vfree_aus2(i) = - 1/Vertex%Cgamma * Vfree_aus(i)
        enddo

        ! Rotation of Vfree
        Vfree_aus(0) = Vertex%normal(1) * Vfree_aus2(0) - Vertex%normal(0) * Vfree_aus2(1)
        Vfree_aus(1) = Vertex%normal(0) * Vfree_aus2(0) + Vertex%normal(1) * Vfree_aus2(1)

        Tolerance = abs(Vfree_aus(1)) / Vertex%sigma0
        if (Tolerance <  tolerance_imposed) then
            Tracn_aus = - Vertex%sigma0
        else
            Tracn_aus = Vfree_aus (1) - Vertex%sigma0
        endif
        if (Tracn_aus < 0) then
            Vertex%Traction(1) = Tracn_aus + Vertex%sigma0
            Vertex%Deltav(1) = 0.
            Tract_aus = Vfree_aus(0) + Vertex%tau0
            delta_disp = abs (Vertex%Deltau(0))

            if (Vertex%Ct * delta_disp**2 * Vertex%beta_p < Vertex%w .and. Vertex%log_vertex) then
                Vertex%beta_p = 1
            else
                Vertex%log_vertex = .false.
                Vertex%beta_p = Vertex%beta_p - dt /Vertex%b * (Vertex%Ct * delta_disp**2 * Vertex%beta_p - Vertex%w)
            endif

            if (Vertex%beta_p < 0) Vertex%beta_p = 0

            !Tracn_aus = -  Vertex%sigma0

            Treshold_AD = -Tracn_aus * Vertex%mud + Vertex%Ct * delta_disp * Vertex%beta_p**2

            if (Tract_aus <= Treshold_AD) then
                Vertex%Traction(0) = Tract_aus - Vertex%tau0
                Vertex%Deltav (0) = 0.
            else
                Vertex%Traction(0) = Treshold_AD - Vertex%tau0
                Vertex%Deltav (0) =  - (Tract_aus-Treshold_AD) * Vertex%Cgamma
            endif
        else     ! opening
            Vertex%Deltav(1) = - Tracn_aus * Vertex%CGamma
            Vertex%Deltav(0) = 0.
            Vertex%Traction(0:1) = 0.
        endif
        Vertex%Deltau(0:1) = Vertex%Deltau(0:1)  + dt * Vertex%Deltav(0:1)

        ! Rotate traction
        Vfree_aus(0) = Vertex%normal(1) * Vertex%Traction(0) + Vertex%normal(0) * Vertex%Traction(1)
        Vfree_aus(1) =- Vertex%normal(0) * Vertex%Traction(0) + Vertex%normal(1) * Vertex%Traction(1)
        Vertex%Traction(0:1) = Vfree_aus(0:1)

        return
    end subroutine traction_on_vertex_adhesion

end module sfaults
!! Local Variables:
!! mode: f90
!! show-trailing-whitespace: t
!! End:
!! vim: set sw=4 ts=8 et tw=80 smartindent : !!
